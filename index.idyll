[meta
  title:"Blueberry Pancakes"
  description:"A toy algorithms problem involving stacks of deliscious blueberry pancakes illustrated in Idyll."
/]

[Header
  title:"Blueberry Pancakes"
  subtitle:"A toy algorithms problem"
  authors:`[
        { name: "Caleb Robinson", link: "http://calebrob.com/" },
        { name: "Fred Hohman", link: "https://fredhohman.com" }
      ]`
/]


Algorithms are pervasive in modern society, and brain teaser type puzzles are a great way to get more familiar with algorithmic thinking!


## Problem

Consider the following problem: you have a spatula and 100 blueberry pancakes, where one pancake has 1 blueberry in it, one pancake has 2 blueberries in it, ..., and one pancake has 100 blueberries in it (yum). These pancakes are in a stack and ordered randomly. If you repeatedly look at the pancake on the top of the stack, then flip the top [i]x[/i] pancakes where [i]x[/i] is the number of blueberries in the top pancake (i.e. pick up the first [i]x[/i] pancakes, reverse them, and set them down), can you prove that, no matter what ordering the pancakes are initially in, the pancake with 1 blueberry will eventually appear on the top of the stack?

Hint: this will work for other numbers of pancakes besides 100, specifically any integer number greater than 1.


## Where can you start?

One of the first things that I like to do when trying to prove something is to work through toy instances of the problem by hand (or in a Jupyter notebook) to get an intuition for what is going on. Let's say that instead of 100 blueberry pancakes, we have 5 blueberry pancakes (again in some random order), what happens if we apply the process described in the problem?


[var name:"flip" value:0 /]
[var name:"reset" value:0 /]
[pancakeStack flip:flip reset:reset numOfPancakes:5/]

You have flipped [Display value:flip format:"d" /] times.

[button onClick:`flip++`]
  Flip me.
[/button]

[button onClick:`reset++;flip=0;`]
  Reset.
[/button]


Cool! We can see that the "1" pancake will come to the top pretty quickly and then get stuck there. If we repeat this a few times, we can also see that, sometimes, all the pancakes will end up sorted. Obviously, this does not happen every time, but it does happen often enough to be curious... Something about the flipping process that we are following wants to sort the pancakes. To dig further into this, we can consider the configurations in which this will happen: the last flip that we do must move the "1" pancake to the top, and keep all of the pancakes in order:

`[Bottom #, -->, Top #]`
* `5,4,3,1,2`
* `5,4,1,2,3`
* `5,1,2,3,4`
* `1,2,3,4,5`

Here we notice that in 3 out of the 4 cases, the "5" pancake is at the bottom of the stack already, and in the case that it is not at the bottom, it must be moved to the bottom!

What happens if we go a level deeper:

* 5,4,3,1,2
	* 5,4,2,1,3
	* 5,2,1,3,4
	* 2,1,3,4,5

* 5,4,1,2,3
	* 5,4,1,3,2
	* 5,3,2,1,4
	* 3,2,1,4,5

* 5,1,2,3,4
	* 4,3,2,1,5
    
* 1,2,3,4,5
	* 1,2,5,4,3

Try to expand one more level and notice what happens! You may have noticed several things:

* It is impossible to find a configuration of pancakes that can be flipped resulting in some of the configurations that we have in our 2nd level. If you keep expanding these you might also notice that the only series that you can expand are those that have elements which are in their sorted location, for example we can expand "5,4,3,1,2" 3 times, around "5", "4" and "3" because these are the numbers that are in their final positions in "5,4,3,1,2".
* Once you flip the largest number in your stack of pancakes, you can not change its position through any subsequent flip. In some cases (like the ones enumerated below), this results in a sorted stack of pancakes, however in other cases, the "1" pancake can come to the top without the remaining pancakes being sorted. This observation is an important one for the formal proof that we give!
* There is at most 1 way to move the last pancake in the stack (by flipping the n'th pancake), there are at most two flips that can move the second to last pancake in the stack (by flipping the n'th and n-1'th pancakes), etc.


### Full tree

* 5,4,3,2,1

    * 5,4,3,1,2

        * 5,4,2,1,3

            * 3,1,2,4,5

            * 5,3,1,2,4

                * 5,3,1,4,2

                    * 2,4,1,3,5

                        * 2,5,3,1,4

                            * 2,5,4,1,3

                * 4,2,1,3,5

        * 5,2,1,3,4

            * 4,3,1,2,5

        * 2,1,3,4,5

            * 2,1,5,4,3

    * 5,4,1,2,3

        * 5,4,1,3,2

            * 5,2,3,1,4

                * 5,2,4,1,3

                    * 3,1,4,2,5

                        * 3,1,4,5,2

                * 4,1,3,2,5

                    * 4,1,5,2,3

                        * 4,1,5,3,2

        * 5,3,2,1,4

            * 4,1,2,3,5

        * 3,2,1,4,5

    * 5,1,2,3,4

        * 4,3,2,1,5
    * 1,2,3,4,5

        * 1,2,5,4,3



## How can you finish?

Experimentally convinced that this isn't an impossible task(!), and equipped with our observations about how the pancake flipping process behaves, we must now determine how to formally prove that the "1" pancake will always come out on top! As we hinted in the previous section, we will use our observation that once you flip the largest pancake in the stack you can't move it again.

Formally, our proof is as follows:

Consider a stack of [i]N[/i] sequential blueberry pancakes.

First, observe that if the largest pancake, pancake [i]N[/i], in the stack is flipped, then it can never be moved again. For example, without loss of generality, let [i]N[/i]=100. Then if pancake 100 is on top of the stack and it is flipped, then it will move to the bottom of the stack. In order to move this pancake again, there would need to be a pancake with more than 100 blueberries in the stack, but we already said [i]N[/i]=100, so this cannot be done.

Now:

* Define a cycle as a list of greater than 2 states of the stack such that after a flip is performed in the last configuration you return to the first configuration
* Assume (for the sake of contradiction) that there is a cycle
* Out of all the first elements from each state in the cycle, one of them will have to be the largest 
* Once you flip the largest it cannot ever return to its initial position based on our reasoning above
* If it can't return to its initial position, then it is impossible to have a cycle, a contradiction.
* Because there are a finite number of configurations of the stack ([i]N[/i] !), and there are no cycles, each flip gives us a new unique configuration, therefore if we keep flipping then we will eventually get to the state with a 1 on top, which then halts