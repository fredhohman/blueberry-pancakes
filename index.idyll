[meta
  title:"Blueberry Pancakes"
  description:"A toy algorithms problem involving stacks of deliscious blueberry pancakes illustrated in Idyll."
/]

[Header
  title:"Blueberry Pancakes"
  subtitle:"A toy algorithms problem"
  authors:`[
        { name: "Caleb Robinson", link: "http://calebrob.com/" },
        { name: "Fred Hohman", link: "https://fredhohman.com" }
      ]`
/]


[script src:"https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"/]

Algorithms are pervasive in modern society, and brain teaser type puzzles are a great way to get more familiar with algorithmic thinking!


## Problem

[Aside]
[image style:`{width: '100%', border: '3px solid #b45326'}` src:"static/images/stack.jpg" /]
Visualize the above.
Warning: you may become hungry.
[/Aside]

Consider the following problem: you have a spatula and 100 blueberry pancakes.
Each pancake is numbered according to how many blueberrys it has.
For example: pancake 1 has 1 blueberry, pancake 2 has two blueberrys, and so on.
// [pancake number:2/]
// where one pancake has 1 blueberry in it, one pancake has 2 blueberries in it, ..., and one pancake has 100 blueberries in it (yum).
These pancakes are in a stack and ordered randomly.

Now, if you repeatedly look at the pancake on the top of the stack, then flip the top [Equation]x[/Equation] pancakes where [Equation]x[/Equation] is the number of blueberries in the top pancake (i.e., pick up the first [Equation]x[/Equation] pancakes, reverse them, and set them down), can you prove the following:

// [pancakeVis /]

**Given any pancake order, if you repeated flip the top pancakes according to our rule, the pancake with 1 blueberry will eventually appear on the top of the stack.**

[br/]

*Hint: this will work for other numbers of pancakes besides 100, specifically any integer number greater than 1.*

## Where can you start?

One of the first things that I like to do when trying to prove something is to work through toy instances of the problem by hand (or in a Jupyter notebook) to get an intuition for what is going on.
Let's say that instead of 100 blueberry pancakes, we have 5 blueberry pancakes (again in some random order), what happens if we apply the process described in the problem?


[var name:"flip" value:0 /]
[var name:"reset" value:0 /]
[pancakeStack flip:flip reset:reset numOfPancakes:5/]

You have flipped **[Display value:flip format:"d" /]** times.

[button onClick:`flip++`]
  Flip the pancakes!
[/button]

[button onClick:`reset++;flip=0;`]
  New batch
[/button]


Cool! We can see that the "1" pancake will come to the top pretty quickly and then get stuck there.
If we repeat this a few times, we can also see that, sometimes, all the pancakes will end up sorted.
This does not happen every time, but it does happen often enough to be curious...
Something about the flipping process that we are following wants to sort the pancakes.

To dig further into this, we can enumerate the configurations in which this will happen (atleast for 5 pancakes!).
In this case, the last flip that we do must move the "1" pancake to the top, and keep all of the pancakes in sorted order; it turns out that there are just 4 cases in which this can happen.
The following tree structure shows the final sorted configuration at the root, "5,4,3,2,1", then all the configurations that could lead to that outcome as children.
Here, the "bottom" of the stack of pancakes is the leftmost number in the string, while the top of the stack is the rightmost number (e.g. in "3,2,4,1,5", pancake "3" is on the bottom and pancake "5" is on top).

[div className:"superRootNode"]
[ul]
[li]5,4,3,2,1[/li]
    [ul]
    [li]1,2,3,4,5[/li]
    [li]5,1,2,3,4[/li]
    [li]5,4,1,2,3[/li]
    [li]5,4,3,1,2[/li]
    [/ul]
[/ul]
[/div]

Here we notice that in 3 out of the 4 cases, the "5" pancake is at the bottom of the stack already, and in the case that it is not at the bottom, it must be moved to the bottom!

What happens if we expand our previous tree structure a level deeper:

[div className:"superRootNode"]
[ul]
[li]5,4,3,2,1[/li]
    [ul]
    [li]1,2,3,4,5[/li]
        [ul]
        [li]1,2,5,4,3[/li]
        [/ul]
    [li]5,1,2,3,4[/li]
        [ul]
        [li]4,3,2,1,5[/li]
        [/ul]
    [li]5,4,1,2,3[/li]
        [ul]
        [li]3,2,1,4,5[/li]
        [li]5,3,2,1,4[/li]
        [li]5,4,1,3,2[/li]
        [/ul]
    [li]5,4,3,1,2[/li]
        [ul]
        [li]2,1,3,4,5[/li]
        [li]5,2,1,3,4[/li]
        [li]5,4,2,1,3[/li]
        [/ul]
    [/ul]
[/ul]
[/div]

Try to expand one more level and notice what happens! You may have observed several things:

* **Not all states are reversible.** It is impossible to find a configuration of pancakes that can be flipped resulting in some of the configurations that we have in our 2nd level. If you keep expanding these you might also notice that the only series that you can expand are those that have elements which are in their sorted location, for example we can expand "5,4,3,1,2" 3 times, around "5", "4" and "3" because these are the numbers that are in their final positions in "5,4,3,1,2".
* **Flipping the largest pancake is a permanent move.** Once you flip the largest number in your stack of pancakes, you can not change its position through any subsequent flip. In some cases (like the ones enumerated in the trees we show), this results in a sorted stack of pancakes, however in other cases, the "1" pancake can come to the top without the remaining pancakes being sorted. [br/][br/] More formally, there is at most 1 way to move the last pancake in the stack (by flipping the [Equation]N[/Equation]'th pancake), there are at most two flips that can move the second to last pancake in the stack (by flipping the n'th and n-1'th pancakes), etc. [br/][br/] *This observation is an important one for our proof!* 

### Full tree

For completeness (and for you, if you don't want to manually expand the above tree), here is the full tree that leads to the sorted end configuration, "5,4,3,2,1"!
Click on nodes to expand them and explore the sequence of states that lead to having the stack of pancakes in sorted order.

[Aside]
*Note that "5,4,3,2,1" is not the only final configuration in which the "1" pancake finishes on top.*
[br/] [br/]
It is possible to reach many other final configurations where "1" is at the top of the stack.
For example, consider the cases where the "1" pancake is initally on top, the process will immediately halt, however the remaining pancakes can be in any of [Equation]4![/Equation] different configurations. 
[/Aside]

[div className:"superRootNode"]
[ul]
 [li] 5,4,3,2,1 [/li]
    [ul]
    [li className:"rootNode"] 1,2,3,4,5 [/li]
       [ul]
       [li className:"treeNode"] 1,2,5,4,3 [/li]
       [/ul]
    [li className:"rootNode"] 5,1,2,3,4 [/li]
       [ul]
       [li className:"treeNode"] 4,3,2,1,5 [/li]
       [/ul]
    [li className:"rootNode"] 5,4,1,2,3 [/li]
       [ul]
       [li className:"treeNode"] 3,2,1,4,5 [/li]
       [li className:"treeNode"] 5,3,2,1,4 [/li]
          [ul]
          [li className:"treeNode"] 4,1,2,3,5 [/li]
          [/ul]
       [li className:"treeNode"] 5,4,1,3,2 [/li]
          [ul]
          [li className:"treeNode"] 2,3,1,4,5 [/li]
          [li className:"treeNode"] 5,2,3,1,4 [/li]
             [ul]
             [li className:"treeNode"] 4,1,3,2,5 [/li]
                [ul]
                [li className:"treeNode"] 4,1,5,2,3 [/li]
                   [ul]
                   [li className:"treeNode"] 4,1,5,3,2 [/li]
                   [/ul]
                [li className:"treeNode"] 4,1,3,5,2 [/li]
                   [ul]
                   [li className:"treeNode"] 4,1,2,5,3 [/li]
                   [/ul]
                [/ul]
             [li className:"treeNode"] 5,2,4,1,3 [/li]
                [ul]
                [li className:"treeNode"] 3,1,4,2,5 [/li]
                   [ul]
                   [li className:"treeNode"] 3,1,4,5,2 [/li]
                   [/ul]
                [/ul]
             [/ul]
          [/ul]
       [/ul]
    [li className:"rootNode"] 5,4,3,1,2 [/li]
       [ul]
       [li className:"treeNode"] 2,1,3,4,5 [/li]
          [ul]
          [li className:"treeNode"] 2,1,5,4,3 [/li]
          [/ul]
       [li className:"treeNode"] 5,2,1,3,4 [/li]
          [ul]
          [li className:"treeNode"] 4,3,1,2,5 [/li]
             [ul]
             [li className:"treeNode"] 4,3,1,5,2 [/li]
             [/ul]
          [/ul]
       [li className:"treeNode"] 5,4,2,1,3 [/li]
          [ul]
          [li className:"treeNode"] 3,1,2,4,5 [/li]
          [li className:"treeNode"] 5,3,1,2,4 [/li]
             [ul]
             [li className:"treeNode"] 4,2,1,3,5 [/li]
             [li className:"treeNode"] 5,3,1,4,2 [/li]
                [ul]
                [li className:"treeNode"] 2,4,1,3,5 [/li]
                   [ul]
                   [li className:"treeNode"] 2,5,3,1,4 [/li]
                      [ul]
                      [li className:"treeNode"] 2,5,4,1,3 [/li]
                      [/ul]
                   [/ul]
                [/ul]
             [/ul]
          [/ul]
       [/ul]
    [/ul]
 [/ul]
 [/div]

[script src:"static/custom.js"/]

## How can you prove it?

Now that we are experimentally convinced that our statement is "probably" true, and are equipped with our observations about how the pancake flipping process behaves, we must now determine how to formally prove that the "1" pancake will always come out on top!
As we hinted in the previous section, we will use our observation that once you flip the largest pancake in the stack you can't move it again.

Formally, our proof is as follows:

Consider a stack of [Equation]N[/Equation] sequentially numbered blueberry pancakes in some random order.

First, observe that if the largest pancake, pancake [Equation]N[/Equation], in the stack is flipped, then it can never be moved again.
For example, without loss of generality, let [Equation]N=100[/Equation].
Then if pancake 100 is on top of the stack and it is flipped, then it will move to the bottom of the stack. In order to move this pancake again, there would need to be a pancake with more than 100 blueberries in the stack, but we already said [Equation]N[/Equation]=100, so this cannot be done.

Now:

* Define a cycle as a list of greater than 2 states of the stack such that after a flip is performed in the last configuration you return to the first configuration.
* Assume (for the sake of contradiction) that there is a cycle.
* Out of all the first elements from each state in the cycle, one of them will have to be the largest .
* Once you flip the largest it cannot ever return to its initial position based on our reasoning above.
* If it can't return to its initial position, then it is impossible to have a cycle, a contradiction.
* Because there are a finite number of configurations of the stack ([Equation]N![/Equation]), and there are no cycles, each flip gives us a new unique configuration, therefore if we keep flipping then we will eventually get to the state with a 1 on top, which then halts
* Because there are a finite number of configurations of the stack ([Equation]N![/Equation]), and there are no cycles, each flip gives us a new unique configuration, therefore if we keep flipping then we will eventually get to the state with a 1 on top, which then halts.

## Acknowledgements
- Thanks to Nebojsa Jojic and Kolya Malkin for the interesting problem.
- Thanks Le Hou for the brainstorming session immediately following the introduction of said interesting problem.


## References
There exists an impressive body of technical work dealing with pancakes.
Interested readers should check out the corresponding [Wikipedia page](https://en.wikipedia.org/wiki/Pancake_sorting).

## Technical footnote

We've included the Python code that we used to generate the trees from above.

```python
def inverse_flip(node, i):
    '''Given a node and an index, return the node
    that results from having previously flipped node[i]'''
    return node[:i] + node[i+1:][::-1] + [node[i]]

def expand(node, indent="", current_depth=0, print_tree=False):
    '''Recursive method for printing out all configurations
    that lead to a given node. Returns the largest depth reached
    by a child node.'''
    if print_tree:
        print(indent,current_depth,node)
    
    largest_depth = current_depth
    for i in range(len(node)-1):
        if i + node[i] == len(node): # we can do a flip
            new_node = inverse_flip(node, i)
            
            # recurse and keep track of the deepest child node
            t_largest_depth = expand(
                new_node,
                indent+"   ",
                current_depth+1,
                print_tree=print_tree
            )
            largest_depth = max(
                largest_depth,
                t_largest_depth
            )

    return largest_depth
```

We can use `expand([5,4,3,2,1], print_tree=True)` to print the tree from earlier in the article:

```python
0 [5, 4, 3, 2, 1]
    1 [1, 2, 3, 4, 5]
       2 [1, 2, 5, 4, 3]
    1 [5, 1, 2, 3, 4]
       2 [4, 3, 2, 1, 5]
    1 [5, 4, 1, 2, 3]
       2 [3, 2, 1, 4, 5]
       2 [5, 3, 2, 1, 4]
          3 [4, 1, 2, 3, 5]
       2 [5, 4, 1, 3, 2]
          3 [2, 3, 1, 4, 5]
          3 [5, 2, 3, 1, 4]
             4 [4, 1, 3, 2, 5]
                5 [4, 1, 5, 2, 3]
                   6 [4, 1, 5, 3, 2]
                5 [4, 1, 3, 5, 2]
                   6 [4, 1, 2, 5, 3]
             4 [5, 2, 4, 1, 3]
                5 [3, 1, 4, 2, 5]
                   6 [3, 1, 4, 5, 2]
    1 [5, 4, 3, 1, 2]
       2 [2, 1, 3, 4, 5]
          3 [2, 1, 5, 4, 3]
       2 [5, 2, 1, 3, 4]
          3 [4, 3, 1, 2, 5]
             4 [4, 3, 1, 5, 2]
       2 [5, 4, 2, 1, 3]
          3 [3, 1, 2, 4, 5]
          3 [5, 3, 1, 2, 4]
             4 [4, 2, 1, 3, 5]
             4 [5, 3, 1, 4, 2]
                5 [2, 4, 1, 3, 5]
                   6 [2, 5, 3, 1, 4]
                      7 [2, 5, 4, 1, 3]
```

From this we can see that the longest possible path to "5,4,3,2,1" takes 7 flips starting from "2,5,4,1,3".
In fact, this is the longest path considering **any** final configuration using "5" pancakes, i.e. out of all possible final configurations using 5 pancakes, the greatest number of flips happens when the final configuration is sorted.
Is it the case for every [Equation]N[/Equation], that the longest path from intial condition to a final condition must be when the final condition is in a sorted order? 
In other words, what is the worst case number of flips that can happen for [Equation]N[/Equation] pancakes?
